# The production environment

First make sure you can [connect to the BPT virtual machine](./virtual_machine.md).

## Files

All files related to the production environment are stored in `/bpt/production`:

```
/bpt/production → ls
• 📁 build-logs
• 📁 code
• 📁 db-data
• 📄 deploy
```

### The build logs

The build logs directory contains the build (and deployment) logs generated by the `deploy` script and the programs/commands it calls. The file name format is `"<date> <time> <git head hash> <university username>"`.

### The code

The code directory is a copy of the git repository. When a developer pushes code there from their machine, git runs the `post-receive` hook stored in `code/.git/hooks` — the hook itself is just a symlink to the `deploy` script listed above. The code directory also has a `.secrets/` directory, used by docker and detailed below in the [Docker section](#docker).

### The database data

The db-data directory is mounted by docker and used by the production environment's copy of postgres. It is completely managed by postgres and should not be edited manually unless you know what you are doing.

### The deployment script

The deployment bash-script is called by git when pushing to the `code` repository. It grabs the git `HEAD` (which logically should always be the latest commit in the `main` branch) hash and uses it as a "revision id". It writes the latest `main` branch to the filesystem using `git checkout`, and builds a docker image and runs it — both using `docker-compose`. It then tags the built docker image with the revision id and as `":latest"`.

## Docker

Docker has a `prod-net` network, to which both the bpt-server and postgres containers are attached:

```
$ docker network list
NETWORK ID     NAME       DRIVER   SCOPE
fd706a1e2ca7   prod-net   bridge   local
…              …          …        …
```

The bpt-server image is labelled "bpt-server" (the latest version is tagged as `:latest`) and the live production container is named `bpt-production`. The database uses the default postgres image and the corresponding live production database container is named `db-production`:

```
$ docker ps
IMAGE               PORTS                               NAMES
bpt-server:latest   0.0.0.0:80->80/tcp, :::80->80/tcp   bpt-production
postgres            5432/tcp                            db-production

$ docker network inspect prod-net
[
    {
        "Name": "prod-net",
        "Containers": {
            "1f77…": {
                "Name": "db-production",
                "IPv4Address": "172.20.0.2/16",
            },
            "9733…": {
                "Name": "bpt-production",
                "IPv4Address": "172.20.0.3/16",
            }
        },
        …
    }
]
```

The bpt-server source code is built into a docker image according to the `code/Dockerfile`. The image is then used in the `code/docker-compose.yml` file.

The compose file specifies

- that the containers should be connected to the production network
- that they should be injected with the secrets (db password) from the `code/.secrets/` directory
- that the bpt-server should have its port 80 exposed
- that the bpt-server container should wait for the database container to be up before running
- that the database container should persist its database (by mounting the `/bpt/production/db-data/` directory)
- that the database should use the database name `bpt`
- that the database is considered up and healthy when `pg_isready -U postgres` says so
